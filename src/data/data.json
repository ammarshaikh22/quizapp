{
  "data": [
    {
      "Ques": "What is the purpose of the never type in TypeScript?",
      "option1": "To represent the type of values that never occur.",
      "option2": "To represent the absence of a value.",
      "option3": "To represent the type of a variable that can hold any value.",
      "option4": "To represent the type of a variable that can be null.",
      "correct": "option1"
    },
    {
      "Ques": "What does an intersection type in TypeScript allow you to do?",
      "option1": "Combine multiple types into a single type.",
      "option2": "Create a type that can be one of several types.",
      "option3": "Define a type that can be null or undefined.",
      "option4": "Create a type that is a subset of another type.",
      "correct": "option1"
    },
    {
      "Ques": "Which operator is used to create an intersection type in TypeScript?",
      "option1": "|",
      "option2": "&",
      "option3": "&&",
      "option4": "||",
      "correct": "option2"
    },
    {
      "Ques": "What happens if two intersecting types have a property with the same name but different types?",
      "option1": "TypeScript will throw an error.",
      "option2": "TypeScript will merge the properties.",
      "option3": "TypeScript will ignore one of the properties.",
      "option4": "TypeScript will create a union type for the property.",
      "correct": "option1"
    },
    {
      "Ques": "How do intersection types affect the properties of the resulting type?",
      "option1": "The resulting type will have all properties of the intersected types.",
      "option2": "The resulting type will have only the common properties of the intersected types.",
      "option3": "The resulting type will have no properties.",
      "option4": "The resulting type will have properties from the first type only.",
      "correct": "option1"
    },
    {
      "Ques": "What is the result of intersecting two types with no common properties?",
      "option1": "A type with all properties from both types.",
      "option2": "A type with no properties.",
      "option3": "A type with only the common properties.",
      "option4": "A type with properties from the first type only.",
      "correct": "option1"
    },
    {
      "Ques": "Can intersection types be used with primitive types in TypeScript?",
      "option1": "Yes, they can be used with any types.",
      "option2": "No, they can only be used with object types.",
      "option3": "Yes, but only with string and number types.",
      "option4": "No, they can only be used with interface types.",
      "correct": "option1"
    },
    {
      "Ques": "What is the primary use case for intersection types in TypeScript?",
      "option1": "To create a new type that combines multiple existing types.",
      "option2": "To create a type that can be one of several types.",
      "option3": "To create a type that can be null or undefined.",
      "option4": "To create a type that is a subset of another type.",
      "correct": "option1"
    },
    {
      "Ques": "How does TypeScript handle methods in intersecting types?",
      "option1": "All methods from both types are included in the resulting type.",
      "option2": "Only methods from the first type are included.",
      "option3": "Only methods from the second type are included.",
      "option4": "Methods are not included in the resulting type.",
      "correct": "option1"
    },
    {
      "Ques": "What is the syntax for defining an intersection type in TypeScript?",
      "option1": "type NewType = TypeA | TypeB;",
      "option2": "type NewType = TypeA & TypeB;",
      "option3": "type NewType = TypeA && TypeB;",
      "option4": "type NewType = TypeA || TypeB;",
      "correct": "option2"
    },
    {
      "Ques": "Can intersection types be used with union types in TypeScript?",
      "option1": "Yes, intersection types can be combined with union types.",
      "option2": "No, intersection types cannot be combined with union types.",
      "option3": "Yes, but only with specific union types.",
      "option4": "No, they are mutually exclusive.",
      "correct": "option1"
    },
    {
      "Ques": "What is the result of intersecting a type with itself?",
      "option1": "The same type.",
      "option2": "An empty type.",
      "option3": "A union type.",
      "option4": "A never type.",
      "correct": "option1"
    },
    {
      "Ques": "How does TypeScript handle optional properties in intersecting types?",
      "option1": "Optional properties are included in the resulting type.",
      "option2": "Optional properties are excluded from the resulting type.",
      "option3": "Optional properties are converted to required properties.",
      "option4": "Optional properties are ignored.",
      "correct": "option1"
    },
    {
      "Ques": "What is the effect of intersecting a type with the any type?",
      "option1": "The resulting type is the any type.",
      "option2": "The resulting type is the original type.",
      "option3": "The resulting type is an empty type.",
      "option4": "The resulting type is a union type.",
      "correct": "option1"
    },
    {
      "Ques": "Can intersection types be used with generic types in TypeScript?",
      "option1": "Yes, intersection types can be used with generic types.",
      "option2": "No, intersection types cannot be used with generic types.",
      "option3": "Yes, but only with specific generic types.",
      "option4": "No, they are mutually exclusive.",
      "correct": "option1"
    },
    {
      "Ques": "What is the result of intersecting a type with the unknown type?",
      "option1": "The resulting type is the unknown type.",
      "option2": "The resulting type is the original type.",
      "option3": "The resulting type is an empty type.",
      "option4": "The resulting type is a union type.",
      "correct": "option1"
    },
    {
      "Ques": "How does TypeScript handle readonly properties in intersecting types?",
      "option1": "Readonly properties are included in the resulting type.",
      "option2": "Readonly properties are excluded from the resulting type.",
      "option3": "Readonly properties are converted to writable properties.",
      "option4": "Readonly properties are ignored.",
      "correct": "option1"
    },
    {
      "Ques": "What is the effect of intersecting a type with the never type?",
      "option1": "The resulting type is the never type.",
      "option2": "The resulting type is the original type.",
      "option3": "The resulting type is an empty type.",
      "option4": "The resulting type is a union type.",
      "correct": "option1"
    },
    {
      "Ques": "Can intersection types be used with interface types in TypeScript?",
      "option1": "Yes, intersection types can be used with interface types.",
      "option2": "No, intersection types cannot be used with interface types.",
      "option3": "Yes, but only with specific interface types.",
      "option4": "No, they are mutually exclusive.",
      "correct": "option1"
    },
    {
      "Ques": "What is the result of intersecting a type with the void type?",
      "option1": "The resulting type is the void type.",
      "option2": "The resulting type is the original type.",
      "option3": "The resulting type is an empty type.",
      "option4": "The resulting type is a union type.",
      "correct": "option1"
    },
    {
      "Ques": "How does TypeScript handle private properties in intersecting types?",
      "option1": "Private properties are included in the resulting type.",
      "option2": "Private properties are excluded from the resulting type.",
      "option3": "Private properties are converted to public properties.",
      "option4": "Private properties are ignored.",
      "correct": "option1"
    },
    {
      "Ques": "What is the effect of intersecting a type with the null type?",
      "option1": "The resulting type is the null type.",
      "option2": "The resulting type is the original type.",
      "option3": "The resulting type is an empty type.",
      "option4": "The resulting type is a union type.",
      "correct": "option1"
    }
  ]
}